{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python bindings for the boreal YARA scanner","text":"<p>The library allows using the boreal library to scan files and processes using YARA rules.</p> <pre><code>import boreal\n\nscanner = boreal.compile(source=\"\"\"\nrule example {\n    meta:\n        description = \"This is an YARA rule example\"\n        date = \"2022-11-11\"\n    strings:\n        $s1 = { 78 6d 6c 68 74 74 70 2e 73 65 6e 64 28 29 }\n        $s2 = \"tmp.dat\" fullword wide\n    condition:\n        any of them\n}\n\"\"\");\n\nresults = scanner.match(data=b\"&lt;\\0t\\0m\\0p\\0.\\0d\\0a\\0t\\0&gt;\\0\")\nassert [rule.name for rule in results] == [\"example\"]\n</code></pre>"},{"location":"#description","title":"Description","text":"<p>This library can serve as a drop-in replacement of the YARA python library, while also providing improvements and saner default behavior.</p> <ul> <li> <p>Literal replacement to the yara library:   replace <code>import yara</code> with <code>import boreal</code> and everything will work.</p> </li> <li> <p>Saner default behavior compared to the yara library: fast scanning enabled   by default, proper hash implementations of python objects, use of the bytes   type in some places to avoid losing information, etc.</p> </li> <li> <p>100% compatibility with the yara library guaranteed if needed through   a yara compatibility mode.</p> </li> </ul>"},{"location":"#yara-compatibility","title":"Yara compatibility","text":"<p>This library guarantees 100% compatibility with the YARA library: the whole API is entirely tested against both libraries to guarantee perfect compatibility.</p> <p>However, a few differences are introduced in the default behavior of this library to ensure that this default behavior fixes some issues in the behavior of the yara library. Those changes are minimal, but can introduce breakage when replacing the yara library.</p> <p>Therefore, you can either:</p> <ul> <li>Use the compatibility mode to ensure 100% compatibility with the yara library:</li> </ul> <pre><code>import boreal\n\nboreal.set_config(yara_compatibility=True)\n</code></pre> <p>This guarantees that the yara library can be replaced and nothing will break. However, it also keeps alive a few issues in this library. It is therefore only recommended to enable this mode when replacing the yara library and wanting to ensure that nothing can break.</p> <ul> <li>Use boreal as is. This fixes a few issues while still providing almost   entirely the same API.</li> </ul> <p>This is recommended if using this library from scratch, or when all the uses of the yara library can be easily checked to ensure nothing will break.</p> <p>For a description of all the differences that exists when the compatibility mode is not enabled, you can consult this documentation.</p>"},{"location":"api/","title":"API documentation","text":"<p>Python bindings for the YARA scanner boreal.</p> <p>Modules:</p> Name Description <code>boreal</code> <p>Python bindings for the YARA scanner boreal.</p> <p>Classes:</p> Name Description <code>AddRuleError</code> <p>Raised when failing to compile a rule</p> <code>CompilerProfile</code> <p>Profile to use when compiling rules.</p> <code>Error</code> <p>Generic boreal error</p> <code>Match</code> <p>Details about a matching rule.</p> <code>Rule</code> <p>Details about a rule contained in the <code>Scanner</code> object.</p> <code>RuleString</code> <p>Details about a string.</p> <code>RulesIter</code> <p>Iterator over the rules of a <code>Scanner</code> object.</p> <code>ScanError</code> <p>Raised when a scan fails</p> <code>Scanner</code> <p>Holds a list of rules, and provides methods to run them on files or bytes.</p> <code>StringMatchInstance</code> <p>Details about a single match instance of a string.</p> <code>StringMatches</code> <p>Details about the matches of a string.</p> <code>SyntaxError</code> <p>Raised when failing to compile a rule</p> <code>TimeoutError</code> <p>Raised when a scan times out</p> <p>Functions:</p> Name Description <code>compile</code> <p>Compile YARA rules and generate a Scanner object.</p> <code>load</code> <p>Load rules from a serialized scanner object.</p> <code>set_config</code> <p>Modify some global parameters</p> <p>Attributes:</p> Name Type Description <code>CALLBACK_ABORT</code> <code>int</code> <p>Return value used in callbacks to abort the scan.</p> <code>CALLBACK_ALL</code> <code>int</code> <p>Call the match callback after a rule is evaluated.</p> <code>CALLBACK_CONTINUE</code> <code>int</code> <p>Return value used in callbacks to signal the scan must continue.</p> <code>CALLBACK_MATCHES</code> <code>int</code> <p>Call the match callback when a rule matches.</p> <code>CALLBACK_NON_MATCHES</code> <code>int</code> <p>Call the match callback when a rule does not match.</p> <code>CALLBACK_TOO_MANY_MATCHES</code> <code>int</code> <p>A string has had too many matches.</p> <code>__version__</code> <code>str</code> <p>Version of the boreal-py library</p> <code>modules</code> <code>list[str]</code> <p>List of availables modules</p>"},{"location":"api/#boreal-attributes","title":"Attributes","text":""},{"location":"api/#boreal.CALLBACK_ABORT","title":"CALLBACK_ABORT  <code>module-attribute</code>","text":"<pre><code>CALLBACK_ABORT: int = 1\n</code></pre> <p>Return value used in callbacks to abort the scan.</p> <p>Callbacks used in the <code>match</code> method should return this value to abort the scan. If the scan is aborted, the match method will not raise any exception but will end immediately, returning the results it has computed so far.</p>"},{"location":"api/#boreal.CALLBACK_ALL","title":"CALLBACK_ALL  <code>module-attribute</code>","text":"<pre><code>CALLBACK_ALL: int = 3\n</code></pre> <p>Call the match callback after a rule is evaluated.</p> <p>If specified in the <code>which_callbacks</code> parameter of the <code>match</code> method the callback will be called after a is evaluated, regardless of whether it has matched or not. the <code>matches</code> attribute of the passed rule can be used to know if the rule has matched or not.</p>"},{"location":"api/#boreal.CALLBACK_CONTINUE","title":"CALLBACK_CONTINUE  <code>module-attribute</code>","text":"<pre><code>CALLBACK_CONTINUE: int = 0\n</code></pre> <p>Return value used in callbacks to signal the scan must continue.</p> <p>Callbacks used in the <code>match</code> method should return this value to keep the scan going.</p>"},{"location":"api/#boreal.CALLBACK_MATCHES","title":"CALLBACK_MATCHES  <code>module-attribute</code>","text":"<pre><code>CALLBACK_MATCHES: int = 1\n</code></pre> <p>Call the match callback when a rule matches.</p> <p>If specified in the <code>which_callbacks</code> parameter of the <code>match</code> method, the callback will be called when a rule matches.</p>"},{"location":"api/#boreal.CALLBACK_NON_MATCHES","title":"CALLBACK_NON_MATCHES  <code>module-attribute</code>","text":"<pre><code>CALLBACK_NON_MATCHES: int = 2\n</code></pre> <p>Call the match callback when a rule does not match.</p> <p>If specified in the <code>which_callbacks</code> parameter of the <code>match</code> method, the callback will be called when a rule does not match.</p>"},{"location":"api/#boreal.CALLBACK_TOO_MANY_MATCHES","title":"CALLBACK_TOO_MANY_MATCHES  <code>module-attribute</code>","text":"<pre><code>CALLBACK_TOO_MANY_MATCHES: int = 6\n</code></pre> <p>A string has had too many matches.</p> <p>This is used in the <code>warnings_callback</code> of the <code>match</code> method to indicate the warning kind.</p>"},{"location":"api/#boreal.CallbackResult","title":"CallbackResult  <code>module-attribute</code>","text":"<pre><code>CallbackResult: TypeAlias = int\n</code></pre> <p>Return status that can be returned by a callback.</p> <p>This must be one of:</p> <ul> <li> <p><code>CALLBACK_CONTINUE</code></p> </li> <li> <p><code>CALLBACK_ABORT</code></p> </li> </ul>"},{"location":"api/#boreal.ConsoleCallback","title":"ConsoleCallback  <code>module-attribute</code>","text":"<pre><code>ConsoleCallback: TypeAlias = Callable[[str], None]\n</code></pre> <p>Callback handling uses of the <code>console</code> module in rules.</p> <p>It receives the log as the lone argument.</p>"},{"location":"api/#boreal.ExternalValue","title":"ExternalValue  <code>module-attribute</code>","text":"<pre><code>ExternalValue: TypeAlias = str | bytes | int | float | bool\n</code></pre> <p>The value of an external symbol usable in a rule condition.</p>"},{"location":"api/#boreal.IncludeCallback","title":"IncludeCallback  <code>module-attribute</code>","text":"<pre><code>IncludeCallback: TypeAlias = Callable[\n    [str, str | None, str], str\n]\n</code></pre> <p>Callback used to resolve include directives.</p> <p>Receive three arguments:</p> <ul> <li> <p>The path being included.</p> </li> <li> <p>The path of the current document. Can be None if the current     document was specified as a string, such as when using the     <code>source</code> or <code>sources</code> parameter.</p> </li> <li> <p>The current namespace.</p> </li> </ul> <p>Must return a string which is the included document.</p>"},{"location":"api/#boreal.MatchCallback","title":"MatchCallback  <code>module-attribute</code>","text":"<pre><code>MatchCallback: TypeAlias = Callable[\n    [RuleDetails], CallbackResult\n]\n</code></pre> <p>Callback called when rules are evaluated.</p>"},{"location":"api/#boreal.MetadataValue","title":"MetadataValue  <code>module-attribute</code>","text":"<pre><code>MetadataValue: TypeAlias = bytes | int | bool\n</code></pre> <p>The value of a metadata key declared in a rule.</p>"},{"location":"api/#boreal.ModulesCallback","title":"ModulesCallback  <code>module-attribute</code>","text":"<pre><code>ModulesCallback: TypeAlias = Callable[\n    [dict[str, Any]], CallbackResult\n]\n</code></pre> <p>Callback called when a module is evaluated.</p> <p>The callback receives the dynamic values of the module as the first argument. The name of the module is accessible with the <code>\"module\"</code> key.</p>"},{"location":"api/#boreal.WarningCallback","title":"WarningCallback  <code>module-attribute</code>","text":"<pre><code>WarningCallback: TypeAlias = Callable[\n    [WarningType, RuleString], CallbackResult\n]\n</code></pre> <p>Callback called when a warning is emitted during a scan.</p>"},{"location":"api/#boreal.WarningType","title":"WarningType  <code>module-attribute</code>","text":"<pre><code>WarningType: TypeAlias = int\n</code></pre> <p>Type of warning passed to the warning callback.</p> <p>This can be one of:</p> <ul> <li><code>CALLBACK_TOO_MANY_MATCHES</code>:     the associated data is a <code>RuleString</code>.</li> </ul>"},{"location":"api/#boreal.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str = '1.0.0'\n</code></pre> <p>Version of the boreal-py library</p>"},{"location":"api/#boreal.modules","title":"modules  <code>module-attribute</code>","text":"<pre><code>modules: list[str]\n</code></pre> <p>List of availables modules</p>"},{"location":"api/#boreal-classes","title":"Classes","text":""},{"location":"api/#boreal.AddRuleError","title":"AddRuleError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when failing to compile a rule</p>"},{"location":"api/#boreal.CompilerProfile","title":"CompilerProfile","text":"<p>Profile to use when compiling rules.</p> <p>Attributes:</p> Name Type Description <code>Memory</code> <code>CompilerProfile</code> <p>Profile to use when compiling rules.</p> <code>Speed</code> <code>CompilerProfile</code> <p>Profile to use when compiling rules.</p>"},{"location":"api/#boreal.CompilerProfile-attributes","title":"Attributes","text":""},{"location":"api/#boreal.CompilerProfile.Memory","title":"Memory  <code>instance-attribute</code>","text":"<pre><code>Memory: CompilerProfile\n</code></pre> <p>Profile to use when compiling rules.</p>"},{"location":"api/#boreal.CompilerProfile.Speed","title":"Speed  <code>instance-attribute</code>","text":"<pre><code>Speed: CompilerProfile\n</code></pre> <p>Profile to use when compiling rules.</p>"},{"location":"api/#boreal.Error","title":"Error","text":"<p>               Bases: <code>Exception</code></p> <p>Generic boreal error</p>"},{"location":"api/#boreal.Match","title":"Match","text":"<p>Details about a matching rule.</p> <p>Methods:</p> Name Description <code>__eq__</code> <p>Return self==value.</p> <code>__ge__</code> <p>Return self&gt;=value.</p> <code>__gt__</code> <p>Return self&gt;value.</p> <code>__hash__</code> <p>Return hash(self).</p> <code>__le__</code> <p>Return self&lt;=value.</p> <code>__ne__</code> <p>Return self!=value.</p> <p>Attributes:</p> Name Type Description <code>meta</code> <code>dict[str, MetadataValue]</code> <p>Dictionary with metadata associated to the rule</p> <code>namespace</code> <code>str</code> <p>Namespace of the matching rule</p> <code>rule</code> <code>str</code> <p>Name of the matching rule</p> <code>strings</code> <code>list[StringMatches]</code> <p>Details about the string matches of the rule.</p> <code>tags</code> <code>list[str]</code> <p>List of tags associated to the rule</p>"},{"location":"api/#boreal.Match-attributes","title":"Attributes","text":""},{"location":"api/#boreal.Match.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, MetadataValue]\n</code></pre> <p>Dictionary with metadata associated to the rule</p>"},{"location":"api/#boreal.Match.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>Namespace of the matching rule</p>"},{"location":"api/#boreal.Match.rule","title":"rule  <code>instance-attribute</code>","text":"<pre><code>rule: str\n</code></pre> <p>Name of the matching rule</p>"},{"location":"api/#boreal.Match.strings","title":"strings  <code>instance-attribute</code>","text":"<pre><code>strings: list[StringMatches]\n</code></pre> <p>Details about the string matches of the rule.</p>"},{"location":"api/#boreal.Match.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: list[str]\n</code></pre> <p>List of tags associated to the rule</p>"},{"location":"api/#boreal.Match-functions","title":"Functions","text":""},{"location":"api/#boreal.Match.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/#boreal.Match.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: object) -&gt; bool\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"api/#boreal.Match.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: object) -&gt; bool\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"api/#boreal.Match.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return hash(self).</p>"},{"location":"api/#boreal.Match.__le__","title":"__le__","text":"<pre><code>__le__(other: object) -&gt; bool\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"api/#boreal.Match.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: object) -&gt; bool\n</code></pre> <p>Return self!=value.</p>"},{"location":"api/#boreal.Readable","title":"Readable","text":"<p>               Bases: <code>Protocol</code></p> <p>A readable object</p>"},{"location":"api/#boreal.Rule","title":"Rule","text":"<p>Details about a rule contained in the <code>Scanner</code> object.</p> <p>Attributes:</p> Name Type Description <code>identifier</code> <code>str</code> <p>Name of the rule</p> <code>is_global</code> <code>bool</code> <p>Is the rule global</p> <code>is_private</code> <code>bool</code> <p>Is the rule private</p> <code>meta</code> <code>dict[str, MetadataValue]</code> <p>Dictionary with metadata associated with the rule</p> <code>namespace</code> <code>str</code> <p>Namespace of the rule</p> <code>tags</code> <code>list[str]</code> <p>List of tags associated with the rule</p>"},{"location":"api/#boreal.Rule-attributes","title":"Attributes","text":""},{"location":"api/#boreal.Rule.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre> <p>Name of the rule</p>"},{"location":"api/#boreal.Rule.is_global","title":"is_global  <code>instance-attribute</code>","text":"<pre><code>is_global: bool\n</code></pre> <p>Is the rule global</p>"},{"location":"api/#boreal.Rule.is_private","title":"is_private  <code>instance-attribute</code>","text":"<pre><code>is_private: bool\n</code></pre> <p>Is the rule private</p>"},{"location":"api/#boreal.Rule.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, MetadataValue]\n</code></pre> <p>Dictionary with metadata associated with the rule</p>"},{"location":"api/#boreal.Rule.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>Namespace of the rule</p>"},{"location":"api/#boreal.Rule.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: list[str]\n</code></pre> <p>List of tags associated with the rule</p>"},{"location":"api/#boreal.RuleDetails","title":"RuleDetails","text":"<p>               Bases: <code>TypedDict</code></p> <p>Details about a rule passed to the match callback.</p> <p>Attributes:</p> Name Type Description <code>matches</code> <code>bool</code> <p>Did the rule match</p> <code>meta</code> <code>dict[str, MetadataValue]</code> <p>List of tags associated to the rule</p> <code>namespace</code> <code>str</code> <p>Namespace of the matching rule</p> <code>rule</code> <code>str</code> <p>Name of the matching rule</p> <code>strings</code> <code>list[StringMatches]</code> <p>Details about the string matches of the rule</p> <code>tags</code> <code>list[str]</code> <p>Dictionary with metadata associated to the rule</p>"},{"location":"api/#boreal.RuleDetails-attributes","title":"Attributes","text":""},{"location":"api/#boreal.RuleDetails.matches","title":"matches  <code>instance-attribute</code>","text":"<pre><code>matches: bool\n</code></pre> <p>Did the rule match</p>"},{"location":"api/#boreal.RuleDetails.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, MetadataValue]\n</code></pre> <p>List of tags associated to the rule</p>"},{"location":"api/#boreal.RuleDetails.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>Namespace of the matching rule</p>"},{"location":"api/#boreal.RuleDetails.rule","title":"rule  <code>instance-attribute</code>","text":"<pre><code>rule: str\n</code></pre> <p>Name of the matching rule</p>"},{"location":"api/#boreal.RuleDetails.strings","title":"strings  <code>instance-attribute</code>","text":"<pre><code>strings: list[StringMatches]\n</code></pre> <p>Details about the string matches of the rule</p>"},{"location":"api/#boreal.RuleDetails.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: list[str]\n</code></pre> <p>Dictionary with metadata associated to the rule</p>"},{"location":"api/#boreal.RuleString","title":"RuleString","text":"<p>Details about a string.</p> <p>Attributes:</p> Name Type Description <code>namespace</code> <code>str</code> <p>Namespace of the rule containing the string.</p> <code>rule</code> <code>str</code> <p>Name of the rule containing the string.</p> <code>string</code> <code>str</code> <p>Name of the string.</p>"},{"location":"api/#boreal.RuleString-attributes","title":"Attributes","text":""},{"location":"api/#boreal.RuleString.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>Namespace of the rule containing the string.</p>"},{"location":"api/#boreal.RuleString.rule","title":"rule  <code>instance-attribute</code>","text":"<pre><code>rule: str\n</code></pre> <p>Name of the rule containing the string.</p>"},{"location":"api/#boreal.RuleString.string","title":"string  <code>instance-attribute</code>","text":"<pre><code>string: str\n</code></pre> <p>Name of the string.</p>"},{"location":"api/#boreal.RulesIter","title":"RulesIter","text":"<p>               Bases: <code>Iterator[Rule]</code></p> <p>Iterator over the rules of a <code>Scanner</code> object.</p> <p>Methods:</p> Name Description <code>__iter__</code> <p>Implement iter(self).</p> <code>__next__</code> <p>Implement next(self).</p>"},{"location":"api/#boreal.RulesIter-functions","title":"Functions","text":""},{"location":"api/#boreal.RulesIter.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; RulesIter\n</code></pre> <p>Implement iter(self).</p>"},{"location":"api/#boreal.RulesIter.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Rule\n</code></pre> <p>Implement next(self).</p>"},{"location":"api/#boreal.ScanError","title":"ScanError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a scan fails</p>"},{"location":"api/#boreal.Scanner","title":"Scanner","text":"<p>               Bases: <code>Iterable[Rule]</code></p> <p>Holds a list of rules, and provides methods to run them on files or bytes.</p> <p>Methods:</p> Name Description <code>__iter__</code> <p>Implement iter(self).</p> <code>match</code> <p>Scan data against the compiled rules.</p> <code>save</code> <p>Save the <code>Scanner</code> object into a bytestring.</p> <code>set_params</code> <p>Modify scan parameters.</p> <p>Attributes:</p> Name Type Description <code>warnings</code> <code>list[str]</code> <p>List of warnings generated when compiling rules.</p>"},{"location":"api/#boreal.Scanner-attributes","title":"Attributes","text":""},{"location":"api/#boreal.Scanner.warnings","title":"warnings  <code>instance-attribute</code>","text":"<pre><code>warnings: list[str]\n</code></pre> <p>List of warnings generated when compiling rules.</p>"},{"location":"api/#boreal.Scanner-functions","title":"Functions","text":""},{"location":"api/#boreal.Scanner.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; RulesIter\n</code></pre> <p>Implement iter(self).</p>"},{"location":"api/#boreal.Scanner.match","title":"match","text":"<pre><code>match(\n    filepath: str | None = None,\n    data: str | bytes | None = None,\n    pid: int | None = None,\n    externals: dict[str, ExternalValue] | None = None,\n    callback: MatchCallback | None = None,\n    which_callbacks: int | None = None,\n    fast: bool | None = None,\n    timeout: int | None = None,\n    modules_data: dict[str, Any] | None = None,\n    modules_callback: ModulesCallback | None = None,\n    warnings_callback: WarningCallback | None = None,\n    console_callback: ConsoleCallback | None = None,\n    allow_duplicate_metadata: bool | None = False,\n) -&gt; list[Match]\n</code></pre> <p>Scan data against the compiled rules.</p> <p>By default, this function will scan the provided input and return a list of the matching rules. However, this behavior can be customized greatly with different parameters.</p> <p>One of <code>filepath</code>, <code>data</code> or <code>pid</code> must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | None</code> <p>Path to the file to scan.</p> <code>None</code> <code>data</code> <code>str | bytes | None</code> <p>Data to scan.</p> <code>None</code> <code>pid</code> <code>int | None</code> <p>The pid of the process to scan.</p> <code>None</code> <code>externals</code> <code>dict[str, ExternalValue] | None</code> <p>A dictionary specifying values for external symbols. The keys are the name of the symbols, and the value are the values to use during the scan, in place of the default value specified during compilation. All symbols must have been declared during compilation, see the <code>externals</code> argument in <code>compile()</code>.</p> <code>None</code> <code>callback</code> <code>MatchCallback | None</code> <p>Callback called when a rule is evaluated. The <code>which_callbacks</code> argument is used to specify which rules are passed to this callback.</p> <code>None</code> <code>which_callbacks</code> <code>int | None</code> <p>Specify which rules to pass to the callback. This must be one of:</p> <ul> <li><code>CALLBACK_MATCHES</code>: the callback is called when a rule       matches.</li> <li><code>CALLBACK_NON_MATCHES</code>: the callback is called when a       rule does not match.</li> <li><code>CALLBACK_ALL</code>: the callback is called in both cases.</li> </ul> <p>The default value depends on the compatibility mode: it is <code>CALLBACK_ALL</code> if in compat mode, <code>CALLBACK_MATCHES</code> otherwise.</p> <p>Note that enabling non matching rules disables fast mode.</p> <code>None</code> <code>fast</code> <code>bool | None</code> <p>Enable or disable <code>fast</code> mode. If fast mode is enabled, strings may not be scanned if rules can be evaluated without them. That is, matching rules are not guaranteed to contain details about string matches. The default value depends on the compatibility mode: it is False if in compat mode, and True otherwise.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>Specify the number of seconds after which the scan times out.</p> <code>None</code> <code>modules_data</code> <code>dict[str, Any] | None</code> <p>Specify data to pass to modules. This is a dictionary mapping the module name to its data. Only the cuckoo module is supported, and the library must have been built with cuckoo support.</p> <code>None</code> <code>modules_callback</code> <code>ModulesCallback | None</code> <p>Callback called when a module is evaluated. The callback will receive the dynamic values of the module.</p> <code>None</code> <code>warnings_callback</code> <code>WarningCallback | None</code> <p>Callback called when the scan emits a warning.</p> <code>None</code> <code>console_callback</code> <code>ConsoleCallback | None</code> <p>Callback called with the <code>console</code> module is used.</p> <code>None</code> <code>allow_duplicate_metadata</code> <code>bool | None</code> <p>If true, the metadata returned with matching rules will be a dictionary that maps the metadata keys to a list of all values associated with this key. This can be used when multiple metadata with the same key are specified in the same rule.</p> <code>False</code> <p>Returns: A list of all the rules that matched.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>A provided argument has the wrong type, or none of the    input arguments were provided.</p> <code>ScanError</code> <p>An error happened during the scan.</p> <code>TimeoutError</code> <p>The scan timed out.</p>"},{"location":"api/#boreal.Scanner.save","title":"save","text":"<pre><code>save(\n    filepath: str | None = None,\n    file: Writable | None = None,\n    to_bytes: bool = False,\n) -&gt; bytes | None\n</code></pre> <p>Save the <code>Scanner</code> object into a bytestring.</p> <p>This method allows serializing the object into a bytestring that can then be reloaded at a later date or on another machine using the <code>load</code> function.</p> <p>See the boreal documentation for more details about this feature and its limitations.</p> <p>One of <code>filepath</code>, <code>file</code> or <code>to_bytes</code> must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | None</code> <p>The path to the file containing the serialized files.</p> <code>None</code> <code>file</code> <code>Writable | None</code> <p>An opened file where the serialization will be written. This can be any object that exposes a <code>write</code> and a <code>flush</code> method, as long the write method accepts bytes.</p> <code>None</code> <code>to_bytes</code> <code>bool</code> <p>If true, return a bytestring containing the serialization.</p> <code>False</code> <p>Returns: The serialize bytestring if <code>to_bytes</code> is true, None otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>A provided argument has the wrong type, or none of the    input arguments were provided.</p> <code>Error</code> <p>The serialization failed.</p>"},{"location":"api/#boreal.Scanner.set_params","title":"set_params","text":"<pre><code>set_params(\n    use_mmap: bool | None = None,\n    string_max_nb_matches: int | None = None,\n    fragmented_scan_mode: str | None = None,\n    process_memory: bool | None = None,\n    max_fetched_region_size: int | None = None,\n    memory_chunk_size: int | None = None,\n) -&gt; None\n</code></pre> <p>Modify scan parameters.</p> <p>Those parameters are documented in details in the boreal documentation.</p> <p>Parameters:</p> Name Type Description Default <code>use_mmap</code> <code>bool | None</code> <p>If true, use mmap to scan files specified by the <code>filepath</code> argument in the <code>match</code> method.</p> <code>None</code> <code>string_max_nb_matches</code> <code>int | None</code> <p>Maximum number of matches for a given string. If this limit is reached, matches are no longer counted nor reported.</p> <code>None</code> <code>fragmented_scan_mode</code> <code>str | None</code> <p>Scan mode to use on fragmented memory, notable process scanning. for more details. This must be one of <code>legacy</code>, <code>fast</code> or <code>single_pass</code>.</p> <code>None</code> <code>process_memory</code> <code>bool | None</code> <p>Scanned bytes are part of the memory of a process.</p> <code>None</code> <code>max_fetched_region_size</code> <code>int | None</code> <p>Maximum size of a fetched region, used during process scanning.</p> <code>None</code> <code>memory_chunk_size</code> <code>int | None</code> <p>Size of memory chunks to scan, used during process scanning.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>A provided argument has the wrong type</p>"},{"location":"api/#boreal.StringMatchInstance","title":"StringMatchInstance","text":"<p>Details about a single match instance of a string.</p> <p>Methods:</p> Name Description <code>__hash__</code> <p>Return hash(self).</p> <code>plaintext</code> <p>The matched data after application of the xor operation.</p> <p>Attributes:</p> Name Type Description <code>matched_data</code> <code>bytes</code> <p>The matched data.</p> <code>matched_length</code> <code>int</code> <p>Length of the entire match before truncation.</p> <code>offset</code> <code>int</code> <p>Offset of the match.</p> <code>xor_key</code> <code>int</code> <p>Xor key used in the match.</p>"},{"location":"api/#boreal.StringMatchInstance-attributes","title":"Attributes","text":""},{"location":"api/#boreal.StringMatchInstance.matched_data","title":"matched_data  <code>instance-attribute</code>","text":"<pre><code>matched_data: bytes\n</code></pre> <p>The matched data.</p> <p>If the match exceeded the <code>max_matched_data</code> limit specified in the <code>set_config</code> function, the data is truncated.</p>"},{"location":"api/#boreal.StringMatchInstance.matched_length","title":"matched_length  <code>instance-attribute</code>","text":"<pre><code>matched_length: int\n</code></pre> <p>Length of the entire match before truncation.</p> <p>This is the actual length of the matched data, which can be different from the length of the <code>matched_data</code> field, since this field can be truncated.</p>"},{"location":"api/#boreal.StringMatchInstance.offset","title":"offset  <code>instance-attribute</code>","text":"<pre><code>offset: int\n</code></pre> <p>Offset of the match.</p>"},{"location":"api/#boreal.StringMatchInstance.xor_key","title":"xor_key  <code>instance-attribute</code>","text":"<pre><code>xor_key: int\n</code></pre> <p>Xor key used in the match.</p>"},{"location":"api/#boreal.StringMatchInstance-functions","title":"Functions","text":""},{"location":"api/#boreal.StringMatchInstance.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return hash(self).</p>"},{"location":"api/#boreal.StringMatchInstance.plaintext","title":"plaintext","text":"<pre><code>plaintext() -&gt; bytes\n</code></pre> <p>The matched data after application of the xor operation.</p> <p>If the string had a xor modifier, this method can be used to get the matched data after application of the xor key.</p>"},{"location":"api/#boreal.StringMatches","title":"StringMatches","text":"<p>Details about the matches of a string.</p> <p>Methods:</p> Name Description <code>__hash__</code> <p>Return hash(self).</p> <code>is_xor</code> <p>Does the string have the xor modifier.</p> <p>Attributes:</p> Name Type Description <code>identifier</code> <code>str</code> <p>Name of the string.</p> <code>instances</code> <code>list[StringMatchInstance]</code> <p>List of matches for the string.</p>"},{"location":"api/#boreal.StringMatches-attributes","title":"Attributes","text":""},{"location":"api/#boreal.StringMatches.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre> <p>Name of the string.</p>"},{"location":"api/#boreal.StringMatches.instances","title":"instances  <code>instance-attribute</code>","text":"<pre><code>instances: list[StringMatchInstance]\n</code></pre> <p>List of matches for the string.</p>"},{"location":"api/#boreal.StringMatches-functions","title":"Functions","text":""},{"location":"api/#boreal.StringMatches.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return hash(self).</p>"},{"location":"api/#boreal.StringMatches.is_xor","title":"is_xor","text":"<pre><code>is_xor() -&gt; bool\n</code></pre> <p>Does the string have the xor modifier.</p>"},{"location":"api/#boreal.SyntaxError","title":"SyntaxError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when failing to compile a rule</p>"},{"location":"api/#boreal.TimeoutError","title":"TimeoutError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a scan times out</p>"},{"location":"api/#boreal.Writable","title":"Writable","text":"<p>               Bases: <code>Protocol</code></p> <p>A writable object</p>"},{"location":"api/#boreal-functions","title":"Functions","text":""},{"location":"api/#boreal.compile","title":"compile  <code>builtin</code>","text":"<pre><code>compile(\n    filepath: str | None = None,\n    filepaths: dict[str, str] | None = None,\n    source: str | None = None,\n    sources: dict[str, str] | None = None,\n    file: Readable | None = None,\n    externals: dict[str, ExternalValue] | None = None,\n    includes: bool = True,\n    error_on_warning: bool = False,\n    include_callback: IncludeCallback | None = None,\n    strict_escape: bool | None = None,\n    profile: CompilerProfile | None = None,\n) -&gt; Scanner\n</code></pre> <p>Compile YARA rules and generate a Scanner object.</p> <p>One of <code>filepath</code>, <code>filepaths</code>, <code>source</code>, <code>sources</code> or <code>file</code> must be passed.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | None</code> <p>Path to a file containing the rules to compile.</p> <code>None</code> <code>filepaths</code> <code>dict[str, str] | None</code> <p>Dictionary where the value is a path to a file, containing rules to compile, and the key is the name of the namespace that will contain those rules.</p> <code>None</code> <code>source</code> <code>str | None</code> <p>String containing the rules to compile.</p> <code>None</code> <code>sources</code> <code>dict[str, str] | None</code> <p>Dictionary where the value is a string containing the rules to compile, and the key is the name of the namespace that will contain those rules.</p> <code>None</code> <code>file</code> <code>Readable | None</code> <p>An opened file containing the rules to compile. This can be any object that exposes a <code>read</code> method.</p> <code>None</code> <code>externals</code> <code>dict[str, ExternalValue] | None</code> <p>Dictionary of externals symbols to make available during compilation. The key is the name of the external symbol, and the value is the original value to assign to this symbol. This original value can be replaced during scanning by specifying an <code>externals</code> dictionary, see the <code>Scanner::match</code> method.</p> <code>None</code> <code>includes</code> <code>bool</code> <p>Allow rules to use the <code>include</code> directive. If set to False, any use of the <code>include</code> directive will result in a compilation error.</p> <code>True</code> <code>error_on_warning</code> <code>bool</code> <p>If true, make the compilation fail when a warning is emitted. If false, warnings can be found in the resulting <code>Scanner</code> object, see <code>Scanner::warnings</code>.</p> <code>False</code> <code>include_callback</code> <code>IncludeCallback | None</code> <p>If specified, this callback is used to resolve callbacks. The callback will receive three arguments:   - The path being included.   - The path of the current document. Can be None if the current     document was specified as a string, such as when using the     <code>source</code> or <code>sources</code> parameter.   - The current namespace. The callback must return a string which is the included document.</p> <code>None</code> <code>strict_escape</code> <code>bool | None</code> <p>If true, invalid escape sequences in regexes will generate warnings. The default value depends on the yara compatibility mode: it is False if in compat mode, or True otherwise.</p> <code>None</code> <code>profile</code> <code>CompilerProfile | None</code> <p>Profile to use when compiling the rules. If not specified, <code>CompilerProfile::Speed</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Scanner</code> <p>a <code>Scanner</code> object that holds the compiled rules.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>A provided argument has the wrong type, or none    of the input arguments were provided.</p> <code>AddRuleError</code> <p>A rule failed to compile.</p>"},{"location":"api/#boreal.load","title":"load  <code>builtin</code>","text":"<pre><code>load(\n    filepath: str | None = None,\n    file: Readable | None = None,\n    data: bytes | None = None,\n) -&gt; Scanner\n</code></pre> <p>Load rules from a serialized scanner object.</p> <p>A scanner can be serialized into a bytestring and reloaded using this function.</p> <p>See the boreal documentation for more details about this feature and its limitations.</p> <p>One of <code>filepath</code>, <code>file</code> or <code>data</code> must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | None</code> <p>The path to the file containing the serialized files.</p> <code>None</code> <code>file</code> <code>Readable | None</code> <p>An opened file containing the serialized files. This can be any   object that exposes a <code>read</code> method, as long as this read method   returns bytes.</p> <code>None</code> <code>data</code> <code>bytes | None</code> <p>The serialized bytes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Scanner</code> <p>a <code>Scanner</code> object.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>A provided argument has the wrong type, or none    of the input arguments were provided.</p> <code>Error</code> <p>The deserialization failed.</p>"},{"location":"api/#boreal.set_config","title":"set_config  <code>builtin</code>","text":"<pre><code>set_config(\n    max_strings_per_rule: int | None = None,\n    max_match_data: int | None = None,\n    stack_size: int | None = None,\n    yara_compatibility: bool | None = None,\n) -&gt; None\n</code></pre> <p>Modify some global parameters</p> <p>Parameters:</p> Name Type Description Default <code>max_strings_per_rule</code> <code>int | None</code> <p>Maximum number of strings allowed in a single rule.   If a rule has more strings than this limit, its compilation will fail.</p> <code>None</code> <code>max_match_data</code> <code>int | None</code> <p>Maximum length for the match data returned in match   results. The match details returned in results will be truncated if   they exceed this limit. Default value is 512</p> <code>None</code> <code>stack_size</code> <code>int | None</code> <p>Unused, this is accepted purely for compatibility with yara.</p> <code>None</code> <code>yara_compatibility</code> <code>bool | None</code> <p>Enable or disable full YARA compatibility. See the   global documentation of this library for more details.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>A provided argument has the wrong type</p>"},{"location":"yara_compatibility_mode/","title":"YARA Compatibility details","text":"<p>By default, Boreal will have some differences with the YARA API on purpose: the YARA API can have non ideal default behavior or have edge cases that are not properly handled and can cause issues. However, the exact behavior of the YARA module is accessible be setting the yara compatibility mode:</p> <pre><code>import boreal\n\nboreal.set_config(yara_compatibility=True)\n</code></pre> <p>If you are not migrating from the YARA API, you should just use the default behavior of boreal and not enable this mode.</p> <p>The list of the differences is documented below. If any of those is problematic for you, you can either align with the boreal behavior, or enable the yara compatibility mode.</p>"},{"location":"yara_compatibility_mode/#fast-mode-by-default","title":"Fast mode by default","text":"<p>Fast mode is enabled by default instead of being opt-in. This enables several optimizations, but means that results may not contain all possible match details.</p> <pre><code>import boreal\n\nrules = boreal.compile(source=\"...\")\n# No need to specify fast=True. `matches` will list all matching rules,\n# but details on the string matches might be missing if the scan did not\n# need to compute them to complete faster.\nmatches = rules.match(data=\"...\")\n</code></pre>"},{"location":"yara_compatibility_mode/#strict-escape-on-by-default","title":"Strict escape on by default","text":"<p>The <code>strict_escape</code> parameter in the <code>compile</code> function defaults to <code>True</code> instead of <code>False</code>. This means that rules that contain invalid escaping in regexes produce warnings by default.</p> <pre><code>import boreal\n\nrules = boreal.compile(source=\"\"\"\nrule foo {\n    strings:\n        $ = /C:\\Users/\n    condition:\n        any of them\n}\n\"\"\")\n# A warning is emitted by default, as opposed to yara\nassert len(rules.warnings) == 1\n</code></pre>"},{"location":"yara_compatibility_mode/#better-hash-implementations","title":"Better hash implementations","text":"<p>The <code>__hash__</code> implementation for the <code>StringMatches</code> and <code>StringMatchInstance</code> objects is improved to avoid collision issues. Those objects are returned in a scan result:</p> <pre><code>import boreal\n\nrules = boreal.compile(source=\"...\")\nresults = rules.match(data=\"...\")\nrule_match = results[0]\nstring_matches = rule_match.strings[0] # This is StringMatches\nstring_instances = string_matches.instances[0] # This is StringMatchInstance\n</code></pre>"},{"location":"yara_compatibility_mode/#string-identifiers-are-not-prefixed-by","title":"String identifiers are not prefixed by '$'","text":"<p>The <code>identifier</code> field in <code>StringMatches</code> is not prefixed by <code>$</code>.</p> <pre><code>import boreal\n\nrules = boreal.compile(source=\"\"\"\nrule foo {\n    strings:\n        $mystr = \"abc\"\n    condition:\n        any of them\nresults = rules.match(data=\"abc\")\nrule_match = results[0]\nstring_matches = rule_match.strings[0]\nassert string_matches.identifier == \"mystr\"  # as opposed to \"$mystr\" in yara\n</code></pre>"},{"location":"yara_compatibility_mode/#textual-metadata-values-are-bytes","title":"Textual metadata values are bytes","text":"<p>Text metadata values are returned as byte-strings instead of strings.</p> <pre><code>import boreal\n    rules = module.compile(source=\"\"\"\n\nrule a {\n    meta:\n        foo = \"a normal string\"\n        bar = \"a string with non ascii bytes: \\\\xCA\\xFE\"\n    condition: true\n}\"\"\")\nmatches = rules.match(data='')\nassert matches[0].meta == {\n    'foo': b'a normal string'\n    'bar': b'a string with non ascii bytes: \\xCA\\xFE' # yara does not return this properly\n}\n</code></pre>"},{"location":"yara_compatibility_mode/#match-callback-only-receive-matching-rules-by-default","title":"Match callback only receive matching rules by default","text":"<p>If <code>which_callbacks</code> is not specified in the <code>match</code> method, the default value is <code>CALLBACK_MATCHES</code> and not <code>CALLBACK_ALL</code>. This default value is almost always what is expected, and enabling the collection of non matching rules disables fast mode, making it undesirable.</p> <pre><code>import boreal\n\ndef cb(rule):\n    # This callback only receives matching rules\n    pass\n\nrules = boreal.compile(source=\"...\")\nmatches = rules.match(data=\"...\", callback=cb)\n</code></pre>"},{"location":"yara_compatibility_mode/#maximum-number-of-matches-is-reduced","title":"Maximum number of matches is reduced","text":"<p>The maximum number of matches for a single string is much reduced compared to the 1 000 000 set in yara. This avoids performance regressions on strings matching too often. The default value is 1000, but this can easily be modified:</p> <pre><code>import boreal\n\nrules = boreal.compile(source=\"...\")\nrules.set_params(string_max_nb_matches=100000)\n</code></pre>"},{"location":"yara_compatibility_mode/#dictionaries-returned-by-modules-uses-byte-strings-as-keys","title":"Dictionaries returned by modules uses byte-strings as keys","text":"<p>Dictionaries that are contained in module values returned in the modules_callback uses bytestrings as keys instead of strings. This can happen for example in the <code>pe.version_info</code> dictionary:</p> <pre><code>rules = boreal.compile(source=\"\"\"\nimport \"pe\"\nrule a { condition: true }\n\"\"\")\n\ndef modules_callback(values):\n    assert values['version_info'][b'InternalName'] == b'MTXEX.DLL'\n    # This is ['version_info']['InternalName'] in yara\n\nrules.match('mtxex.dll', modules_callback=modules_callback)\n</code></pre> <p>This is required because those keys are not guaranteed to be strings. There is a known bug in yara due to this: if a dictionary key is not a proper string, the scan will fail.</p>"}]}